#!/usr/bin/env python

# ----------------------------------------------------------------------------
# file: ronin_base_controller.py
# pkg:  ronin_base
# 
# node: ronin_base_controller
# sub:  /cmd_vel
# pub:  /odom     
# 
# desc: Subscribes to /cmd_vel messages generated by ronin_teleop nodes and
#       send c.p.s. velocities to motors
#      
# ver:  0.1 (jul-18)
#
# upd:        
# ----------------------------------------------------------------------------

# import tweaked version of PyCmdMessenger for Python 2.x
import PyCmdMessenger_py2 as PyCmdMessenger
import serial.tools.list_ports
import math
import rospy
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Quaternion
from nav_msgs.msg import Odometry
from tf.broadcaster import TransformBroadcaster


_NODE_NAME = "ronin_base_controller"

# Motor values
# Pololu 25D 6v 20.4:1 48CPR
_DEFAULT_MOTOR_CPR = 979.62
_DEFAULT_MAX_LINEAR_VEL = 0.4
_DEFAULT_MAX_ANGULAR_VEL = 1.25

# Robot geometry    
_DEFAULT_WHEEL_RADIUS = 0.0325
_DEFAULT_WHEEL_DIST = 0.19

# ROS
_DEFAULT_ODOM_RATE = 10.0
_DEFAULT_BASE_FRAME = "base_footprint"
_DEFAULT_ODOM_FRAME = "odom"

class BoardController():
    """
    Main board controller
    """

    # List of commands and argument formats
    commands = [["cmd_set_motor_params","ffff"],
                ["cmd_set_cps_pid_params","fff"],
                ["cmd_set_motor_pwm","ii"],
                ["cmd_get_motor_pwm", ""],
                ["cmd_ret_motor_pwm", "ii"],
                ["cmd_get_encoder_ticks", ""],
                ["cmd_ret_encoder_ticks", "ll"],
                ["cmd_set_motor_cps", "ff"],
                ["cmd_get_motor_cps", ""],
                ["cmd_ret_motor_cps", "ff"],
                ["cmd_get_odometry", ""],
                ["cmd_ret_odometry", "fff"],
                ["cmd_reset_system", ""],
                ["cmd_ret_line", "s"]]     
    
    def __init__(self, motor_cpr, wheel_radius, wheel_distance,
                 max_linear_vel, max_angular_vel,
                 odom_rate, base_frame, odom_frame):
        """
        Input:
            motor_cpr:
                motor encoder counts per revolution (4x resolution)
            wheel_radius:
                radius of the robot wheels (meters)
            wheel_distance:
                distance between robot wheels (meters)
            max_linear_vel:
                maximun speed of the robot (m/s)
            max_angular_vel:
                maximun angular speed of the robot (rad/s)
            odom_rate:
                publishing rate of robot odometry
            base_frame:
                robot base frame name
            odom_frame:
                odometry frame name
        """
        
        self.motor_cpr = motor_cpr
        self.wheel_radius = wheel_radius
        self.wheel_distance = wheel_distance        
        self.max_linear_vel = max_linear_vel
        self.max_angular_vel = max_angular_vel
        self.odom_rate = odom_rate
        self.base_frame = base_frame
        self.odom_frame = odom_frame
        
        # Initialize ArduinoBoard instance
        self.port = self.getBoardUSBPort(self._DEFAULT_PORT_PREFIX)        
        if len(self.port) == 0:
            rospy.logfatal("Not founded any ttyACM port. Exiting...")
            exit()
        
        rospy.loginfo("Connecting to port %s..." % self.port[0])        
        
        # Arduino Zero >> int 4 bytes
        self.board = PyCmdMessenger.ArduinoBoard(self.port[0], 
                                        self._DEFAULT_BAUD_RATE, 
                                        int_bytes=4)                                            
                
        # Initialize the messenger
        self.cmd = PyCmdMessenger.CmdMessenger(self.board, 
                                               BoardController.commands)

        rospy.loginfo("done. Connecction to serial port %s established" % 
                                                                self.port[0]) 
        
        # Reset board
        rospy.loginfo("Resetting board counters")
        self.cmd.send("cmd_reset_system")
                                                  
        # ROS Node Subscriber
        self.sub_cmd_vel = rospy.Subscriber('cmd_vel', Twist, 
                                              self.compute_motor_velocities_cb, 
                                              queue_size = 1)      
        # Odometry publisher    
        self.odom_pub = rospy.Publisher("odom", Odometry, queue_size=10)
        self.odom_broadcaster = TransformBroadcaster()
        rospy.Timer(rospy.Duration(1.0/self.odom_rate), self.update_odometry)                                                               
        
    def getBoardUSBPort(self, port_prefix):
        # Try to find the associated USB COM port
        comports = [tuple(p) for p in list(serial.tools.list_ports.comports())]
        
        # List of ports containing port_prefix
        port = [port[0] for port in comports if port_prefix in port[0]]
            
        return port             

    def compute_motor_velocities_cb(self, twist_msg):
        """
        Gets /cmd_vel values and compute the appropriate motor velocities 
        in c.p.s. to send to the robot base
        
        Vr = (2*linear_vel + angular_vel*wheel_distance)/2*wheel_radius
        Vl = (2*linear_vel - angular_vel*wheel_distance)/2*wheel_radius
        """
        linear_vel = twist_msg.linear.x      
        angular_vel = twist_msg.angular.z 
        
        # Right and Left motor velocities in rad/s
        v2 = 2 * linear_vel
        r2 = 2 * self.wheel_radius
        wL = angular_vel * self.wheel_distance
        
        vr = (v2 - wL)/r2
        vl = (v2 + wL)/r2
        
        # Compute velocities in c.p.s
        rads_to_counts = self.motor_cpr / (2*math.pi)
        vr *= rads_to_counts
        vl *= rads_to_counts
        
        # Send Command
        #rospy.loginfo("vr: %f    vl: %f" % (vr,vl))
        self.cmd.send("cmd_set_motor_cps", vr, vl)
        
    def update_odometry(self, event):
        """
        Gets the current odometry from the robot and publish the ROS transform
        
        """
        # send command
        self.cmd.send("cmd_get_odometry")    
        
        # receive response from Arduino
        data = self.cmd.receive() 
        x = data[1][0]
        y = data[1][1]
        theta = data[1][2]
        now = rospy.Time.now()
        
        # publish the odom information
        quaternion = Quaternion()
        quaternion.x = 0.0
        quaternion.y = 0.0
        quaternion.z = math.sin( theta / 2 )
        quaternion.w = math.cos( theta / 2 )
        self.odom_broadcaster.sendTransform(
            (x, y, 0),
            (quaternion.x, quaternion.y, quaternion.z, quaternion.w),
            now,
            self.base_frame,
            self.odom_frame
            )
        
        odom = Odometry()
        odom.header.stamp = now
        odom.header.frame_id = self.odom_frame
        odom.pose.pose.position.x = x
        odom.pose.pose.position.y = y
        odom.pose.pose.position.z = 0
        odom.pose.pose.orientation = quaternion
        odom.child_frame_id = self.base_frame
        odom.twist.twist.linear.x = 0   # linear velocity
        odom.twist.twist.linear.y = 0
        odom.twist.twist.angular.z = 0  # angular velocity
        self.odom_pub.publish(odom)                
        
class ZeroBoardController(BoardController):        
    # Board serial connection
    _DEFAULT_PORT_PREFIX = "ttyACM"
    _DEFAULT_BAUD_RATE = 115200

    def __init__(self, motor_cpr, wheel_radius, wheel_distance,
                 max_linear_vel, max_angular_vel,
                 odom_rate, base_frame, odom_frame):
        BoardController.__init__(self, motor_cpr, wheel_radius, wheel_distance,
                                 max_linear_vel, max_angular_vel,
                                 odom_rate, base_frame, odom_frame)
        
if __name__ == '__main__':
    # init ROS node
    rospy.init_node(_NODE_NAME, log_level=rospy.INFO)
    
    # Motor and base geometry params
    motor_cpr = rospy.get_param("~motor_cpr", _DEFAULT_MOTOR_CPR)
    wheel_radius = rospy.get_param("~wheel_radius", _DEFAULT_WHEEL_RADIUS)
    wheel_distance = rospy.get_param("~wheel_distance", _DEFAULT_WHEEL_DIST)      
    max_linear_vel = rospy.get_param("~max_linear_vel", 
                                      _DEFAULT_MAX_LINEAR_VEL)
    max_angular_vel = rospy.get_param("~max_angular_vel",
                                       _DEFAULT_MAX_ANGULAR_VEL)    

    odom_rate = rospy.get_param("~odom_rate", _DEFAULT_ODOM_RATE)
    base_frame = rospy.get_param("~base_frame", _DEFAULT_BASE_FRAME)
    odom_frame = rospy.get_param("~odom_frame", _DEFAULT_ODOM_FRAME)
                                   
    # create Zero board object
    zero = ZeroBoardController(motor_cpr, wheel_radius, wheel_distance, 
                               max_linear_vel, max_angular_vel,
                               odom_rate, base_frame, odom_frame)

    rospy.spin()